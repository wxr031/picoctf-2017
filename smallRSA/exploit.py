#!/usr/bin/env python3

import math
from fractions import Fraction
from decimal import Decimal, getcontext
import struct

e = 165528674684553774754161107952508373110624366523537426971950721796143115780129435315899759675151336726943047090419484833345443949104434072639959175019000332954933802344468968633829926100061874628202284567388558408274913523076548466524630414081156553457145524778651651092522168245814433643807177041677885126141
n = 380654536359671023755976891498668045392440824270475526144618987828344270045182740160077144588766610702530210398859909208327353118643014342338185873507801667054475298636689473117890228196755174002229463306397132008619636921625801645435089242900101841738546712222819150058222758938346094596787521134065656721069
c = 299332969197175711189362475973176110018924953676765834206557170936449056044940463424192591024333960287834765144663838107275612534099922176841029550103731130301225827761650271435325506311287472459681420052612378517579125881519989567977576917642556419749968152894536307775054555830688673518208539947146038594927

def rat2cont_quot(x, y):
	"""
	Computes list of continued quotients
	"""
	cont = []
	while y != 0:
		cont.append(x // y)
		x, y = y, x % y
	return cont

def cont2frac(cont):
	"""
	Turns continued quotients into fraction
	"""
	if cont == [0]:
		return None
	frac = Fraction(0, 1)
	for p in cont[::-1]:
		frac = 1 / (frac + p)
	return 1 / frac

def rat2frac_list(x, y):
	"""
	Compute list of fractions with given continued quotients
	"""
	cont = rat2cont_quot(x, y)
	frac = []
	for i in range(len(cont)):
		frac.append(cont2frac(cont[:(i+1)]))
	return frac

def get_roots(a, b, c):
	"""
	Solve quadratic equation
	"""
	D = b ** 2 - 4 * a * c
	if D < 0:
		return None, None
	return ((-b + D.sqrt()) / (2 * a)), ((-b - D.sqrt()) / (2 * a))

# get the continued fractions of e / n
cont_quot = rat2frac_list(e, n)

# set precision of Decimal to a very large number
getcontext().prec = 1024

for frac in cont_quot:
	if frac == None:
		continue
	k, d = frac.numerator, frac.denominator
	phi = (e * d - 1) // k

	# solve p and q
	p, q = get_roots(Decimal(1), Decimal(phi - n - 1), Decimal(n))
	if p is None and q is None:
		continue
	else:
		p, q = int(p), int(q)
	if p * q == n:
		break
else:
	print('No Solution')
	exit(1)

msg = pow(c, d, n)

def int_to_bytes(data):
	return data.to_bytes((data.bit_length() + 7) // 8, byteorder='big')

print(int_to_bytes(msg))
